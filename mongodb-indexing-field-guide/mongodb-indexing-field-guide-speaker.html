<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MongoDB Indexing Field Guide</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #1e1e1e;
            color: #ffffff;
            line-height: 1.6;
        }
        
        .slide {
            min-height: 100vh;
            padding: 40px;
            box-sizing: border-box;
            position: relative;
        }
        
        .slide-content {
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 0.5em;
            color: #61dafb;
        }
        
        h2 {
            font-size: 2em;
            margin-bottom: 0.5em;
            color: #61dafb;
        }
        
        h3 {
            font-size: 1.5em;
            margin-bottom: 0.5em;
            color: #61dafb;
        }
        
        p {
            font-size: 1.2em;
            margin-bottom: 1em;
        }
        
        ul, ol {
            font-size: 1.1em;
            margin-bottom: 1em;
        }
        
        li {
            margin-bottom: 0.5em;
        }
        
        code {
            background: #2d2d2d;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        pre {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
        }
        
        pre code {
            background: none;
            padding: 0;
        }
        
        /* Notes Section */
        .notes-section {
            margin-top: 30px;
            border-top: 2px solid #61dafb;
            padding-top: 20px;
        }
        
        .notes-toggle {
            background: #61dafb;
            color: #1e1e1e;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .notes-toggle:hover {
            background: #4fa8c5;
        }
        
        .notes-content {
            display: none;
            background: #2d2d2d;
            border: 1px solid #61dafb;
            border-radius: 8px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.5;
        }
        
        .notes-content.show {
            display: block;
        }
        
        .notes-content h4 {
            color: #61dafb;
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        /* Slide Navigation */
        .slide-nav {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 30, 0.9);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        
        .slide-nav button {
            background: #61dafb;
            color: #1e1e1e;
            border: none;
            padding: 5px 10px;
            margin: 0 2px;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .slide-nav button:hover {
            background: #4fa8c5;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .slide {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            h2 {
                font-size: 1.5em;
            }
            
            .slide-nav {
                position: static;
                text-align: center;
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="slide-nav">
        <button onclick="previousSlide()">â†</button>
        <span id="slide-counter">1</span>
        <button onclick="nextSlide()">â†’</button>
    </div>
    
    <div id="slides-container">
        <h1 id="mongodb-indexing-field-guide">ğŸ“– MongoDB Indexing Field
        Guide</h1>
        <h2
        id="performance-query-optimization-for-node.js-developers">Performance
        &amp; Query Optimization for Node.js Developers</h2>
        <p><em>Understanding how indexes work and how the optimizer
        evaluates your queries</em></p>
        <div class="notes">
        <p><strong>Opening Hook:</strong> â€œHow many of you have seen a
        query that takes 30 seconds in production but runs instantly on
        your laptop? Today weâ€™re going to fix that forever.â€</p>
        <p><strong>Introduction:</strong> â€œIâ€™m going to teach you to
        think like MongoDBâ€™s query optimizer. By the end of this
        session, youâ€™ll know exactly why your queries are slow and how
        to make them fast.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="about-this-session">ğŸ‘‹ About This Session</h1>
        <p><strong>Target Audience:</strong> Node.js &amp; Mongoose
        developers (all levels)</p>
        <p><strong>What Youâ€™ll Learn:</strong> - How MongoDBâ€™s query
        optimizer really works - Index types and when to use them -
        Query patterns that help/hurt performance - Aggregation pipeline
        optimization - Mongoose-specific indexing considerations -
        Common pitfalls and how to avoid them</p>
        <div class="notes">
        <p><strong>Audience Check:</strong> â€œWho here has used MongoDB
        in production? Who has built indexes? Who has cursed at a slow
        aggregation pipeline? Perfect - youâ€™re in the right place.â€</p>
        <p><strong>Promise:</strong> â€œWeâ€™re going beyond â€˜just add an
        indexâ€™ - youâ€™ll understand WHY indexes work, WHEN they donâ€™t
        help, and HOW to design them for your specific use cases.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="why-indexes-matter">ğŸ¯ Why Indexes Matter</h1>
        <pre><code>// Without index: O(n) - scans entire collection
db.users.find({ email: &quot;john@example.com&quot; })

// With index: O(log n) - direct lookup
db.users.createIndex({ email: 1 })
db.users.find({ email: &quot;john@example.com&quot; })</code></pre>
        <p><strong>Performance Impact:</strong> - 1M documents: ~1ms vs
        ~1000ms - 10M documents: ~1ms vs ~10,000ms - Linear growth vs
        logarithmic growth</p>
        <div class="notes">
        <p><strong>Fundamental Truth:</strong> â€œSingle field indexes are
        your bread and butter. Master these first before getting fancy
        with compound indexes.â€</p>
        <p><strong>Common Mistake:</strong> Developers often skip single
        field indexes and jump to compound ones too early.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="mongodb-query-optimizer-overview">ğŸ§  MongoDB Query
        Optimizer Overview</h1>
        <h2 id="the-three-stage-process">The Three-Stage Process</h2>
        <ol type="1">
        <li><strong>Query Parsing</strong> - Understands what you
        want</li>
        <li><strong>Plan Selection</strong> - Chooses how to get it</li>
        <li><strong>Execution</strong> - Actually runs the query</li>
        </ol>
        <p>The optimizer is <strong>cost-based</strong> and
        <strong>learned</strong> - it remembers what works!</p>
        <div class="notes">
        <p><strong>Key Point:</strong> â€œThe optimizer is like a GPS for
        your data. It has multiple routes but always tries to pick the
        fastest one. Our job is to build the highways (indexes) it
        needs.â€</p>
        <p><strong>Technical Emphasis:</strong> Stress that the
        optimizer is cost-based - itâ€™s doing math, not magic.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="query-optimizer-stage-1---parsing">ğŸ” Query Optimizer:
        Stage 1 - Parsing</h1>
        <pre><code>// Your query
db.users.find({ 
  status: &quot;active&quot;, 
  age: { $gte: 25 }, 
  city: &quot;New York&quot; 
}).sort({ lastLogin: -1 })

// Optimizer identifies:
// - Filter fields: status, age, city
// - Filter types: equality, range, equality  
// - Sort fields: lastLogin (descending)
// - Operation type: find</code></pre>
        <div class="notes">
        <p><strong>Key Insight:</strong> â€œThe optimizer isnâ€™t magic -
        itâ€™s methodical. It breaks down your query into parts it can
        understand and optimize.â€</p>
        <p><strong>Walk Through:</strong> â€œNotice how it categorizes
        each field by usage: equality matches are the most selective,
        ranges come next, and sorts determine result order. This
        categorization drives index selection.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="query-optimizer-stage-1---parsing-field-usage-types">ğŸ”
        Query Optimizer: Stage 1 - Parsing (Field Usage Types)</h1>
        <p><strong>Field Usage Types:</strong> -
        <strong>Equality</strong>: <code>status: "active"</code> -
        <strong>Range</strong>: <code>age: { $gte: 25 }</code> -
        <strong>Sort</strong>: <code>sort({ lastLogin: -1 })</code></p>
        <div class="notes">
        <p><strong>Critical Limitation:</strong> â€œHereâ€™s where most
        developers get stuck - MongoDB can only use one range operation
        efficiently per query. Multiple ranges = performance
        problems.â€</p>
        <p><strong>Practical Advice:</strong> â€œWhen you see queries with
        $in and $gte together, thatâ€™s a red flag. Consider restructuring
        your query or creating multiple optimized indexes.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="query-optimizer-stage-2---plan-selection">âš¡ Query
        Optimizer: Stage 2 - Plan Selection</h1>
        <h2 id="index-candidate-evaluation">Index Candidate
        Evaluation</h2>
        <pre><code>// Available indexes:
{ status: 1 }                    // Single field
{ age: 1, status: 1 }           // Compound
{ city: 1, lastLogin: -1 }      // Compound with sort
{ status: 1, lastLogin: -1 }    // ESR pattern</code></pre>
        <p><strong>Optimizer considers:</strong> - <strong>Field
        coverage</strong> - Which fields can use index -
        <strong>Selectivity</strong> - How much data gets filtered out -
        <strong>Sort efficiency</strong> - Can index provide sort
        order</p>
        <div class="notes">
        <p><strong>Key Point:</strong> [Add speaker notes for this
        slide]</p>
        <p><strong>Emphasis:</strong> [Add key talking points]</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="the-esr-rule-equality-sort-range">ğŸ¯ The ESR Rule
        (Equality, Sort, Range)</h1>
        <h2 id="optimal-index-field-order">Optimal Index Field
        Order</h2>
        <pre><code>// Query pattern
db.users.find({ 
  status: &quot;active&quot;,        // Equality
  age: { $gte: 25 }       // Range
}).sort({ lastLogin: -1 }) // Sort

// Optimal index: ESR order
{ status: 1, lastLogin: -1, age: 1 }
//   E          S            R</code></pre>
        <p><strong>Why ESR works:</strong> 1. <strong>Equality</strong>
        - Most selective, finds exact matches 2. <strong>Sort</strong> -
        Provides sorted results without extra work 3.
        <strong>Range</strong> - Filters remaining documents</p>
        <div class="notes">
        <p><strong>Golden Rule:</strong> â€œESR is the most important
        acronym in MongoDB. If you remember nothing else, remember
        ESR.â€</p>
        <p><strong>Teaching Story:</strong> â€œA developer once asked me
        why their compound index wasnâ€™t working. They had Range, Sort,
        Equality. I said â€˜Youâ€™re driving backwards on the highway.â€™â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="index-types-deep-dive">ğŸ“Š Index Types Deep Dive</h1>
        <h2 id="single-field-indexes">Single Field Indexes</h2>
        <pre><code>// Basic single field
db.users.createIndex({ email: 1 })

// Good for:
db.users.find({ email: &quot;john@example.com&quot; })
db.users.find({ email: { $in: [&quot;john@example.com&quot;, &quot;jane@example.com&quot;] } })

// Direction matters for sorting:
db.users.createIndex({ createdAt: -1 })  // Newest first</code></pre>
        <div class="notes">
        <p><strong>Technical Emphasis:</strong> â€œMongoDB can only use
        one range efficiently per query. If you have multiple ranges,
        only the first one in the index gets optimized.â€</p>
        <p><strong>Practical Example:</strong> Relate to filtering a
        phone book - equality finds the section, sort organizes within
        it, range picks the subset.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="compound-indexes">ğŸ”— Compound Indexes</h1>
        <pre><code>// Order matters!
db.users.createIndex({ status: 1, age: 1, city: 1 })

// Can efficiently support:
{ status: &quot;active&quot; }
{ status: &quot;active&quot;, age: 25 }
{ status: &quot;active&quot;, age: 25, city: &quot;NYC&quot; }

// Cannot efficiently support:
{ age: 25 }                    // Skips first field
{ city: &quot;NYC&quot; }               // Skips first fields
{ age: 25, city: &quot;NYC&quot; }      // Skips first field</code></pre>
        <p><strong>Left-to-Right Rule:</strong> Must use fields from
        left to right</p>
        <div class="notes">
        <p><strong>Key Teaching Moment:</strong> â€œCompound indexes are
        like postal addresses. Order matters! â€˜123 Main St, NYCâ€™ works.
        â€˜NYC, 123 Main Stâ€™ doesnâ€™t make sense.â€</p>
        <p><strong>Set Expectations:</strong> â€œThis is where 80% of
        performance problems get solved or created.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="specialized-index-types">ğŸ¨ Specialized Index Types</h1>
        <h2 id="text-indexes">Text Indexes</h2>
        <pre><code>db.articles.createIndex({ title: &quot;text&quot;, content: &quot;text&quot; })
db.articles.find({ $text: { $search: &quot;mongodb indexing&quot; } })</code></pre>
        <h2 id="geospatial-indexes">Geospatial Indexes</h2>
        <pre><code>db.places.createIndex({ location: &quot;2dsphere&quot; })
db.places.find({ location: { $near: { $geometry: { type: &quot;Point&quot;, coordinates: [-73.97, 40.77] } } } })</code></pre>
        <h2 id="partial-indexes">Partial Indexes</h2>
        <pre><code>db.users.createIndex({ email: 1 }, { partialFilterExpression: { status: &quot;active&quot; } })</code></pre>
        <div class="notes">
        <p><strong>Advanced Concept:</strong> â€œMongoDB can sometimes
        combine multiple indexes. Itâ€™s clever, but donâ€™t rely on it for
        performance-critical queries.â€</p>
        <p><strong>Best Practice:</strong> â€œWhen you need intersection
        regularly, create a proper compound index instead.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="aggregation-pipeline-optimization">ğŸ”„ Aggregation
        Pipeline Optimization</h1>
        <h2 id="pipeline-stages-and-indexes">Pipeline Stages and
        Indexes</h2>
        <pre><code>db.users.aggregate([
  { $match: { status: &quot;active&quot;, age: { $gte: 25 } } },  // Can use index
  { $sort: { lastLogin: -1 } },                         // Can use index
  { $group: { _id: &quot;$department&quot;, count: { $sum: 1 } } }, // Creates new data
  { $sort: { count: -1 } }                              // Needs in-memory sort
])

// Optimal index:
{ status: 1, lastLogin: -1, age: 1 }</code></pre>
        <p><strong>Key Principle:</strong> Early pipeline stages can use
        indexes, later stages often canâ€™t</p>
        <div class="notes">
        <p><strong>Transition:</strong> â€œNow weâ€™re moving from simple
        queries to complex data processing. The rules get more
        nuanced.â€</p>
        <p><strong>Framework:</strong> â€œThink of aggregation stages like
        an assembly line. Each stage should make the next oneâ€™s job
        easier.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="aggregation-match-and-sort-optimization">ğŸ“ˆ Aggregation:
        $match and $sort Optimization</h1>
        <pre><code>// GOOD: $match first, then $sort
db.orders.aggregate([
  { $match: { status: &quot;completed&quot;, date: { $gte: new Date(&quot;2024-01-01&quot;) } } },
  { $sort: { amount: -1 } },
  { $limit: 10 }
])

// Index: { status: 1, amount: -1, date: 1 }</code></pre>
        <div class="notes">
        <p><strong>Critical Point:</strong> â€œ$match is your performance
        foundation. Get this wrong and everything downstream
        suffers.â€</p>
        <p><strong>Mantra:</strong> â€œFilter early, filter often, filter
        with indexes.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="aggregation-match-and-sort-optimization-part-1">ğŸ“ˆ
        Aggregation: $match and $sort Optimization (Part 1)</h1>
        <pre><code>// BAD: $sort before selective $match
db.orders.aggregate([
  { $sort: { amount: -1 } },  // Sorts entire collection!
  { $match: { status: &quot;completed&quot; } },
  { $limit: 10 }
])</code></pre>
        <div class="notes">
        <p><strong>Optimization Mantra:</strong> â€œThe golden rule:
        filter early, sort smartly. This slide shows the difference
        between queries that finish in milliseconds vs ones that
        timeout.â€</p>
        <p><strong>Performance Reality:</strong> â€œNotice how moving
        $match before $sort reduces the dataset size. Itâ€™s like
        decluttering your desk before organizing it - much easier to
        sort 100 items than 1 million.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="aggregation-match-and-sort-optimization-part-3">ğŸ“ˆ
        Aggregation: $match and $sort Optimization (Part 3)</h1>
        <div class="notes">
        <p><strong>Continuation:</strong> This slide continues the
        content from the previous slide.</p>
        <p><strong>Key Focus:</strong> Maintain the same energy and
        emphasis from the previous section.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="aggregation-lookup-optimization">ğŸ¯ Aggregation: $lookup
        Optimization</h1>
        <pre><code>// Users collection
db.users.createIndex({ _id: 1 })              // Default
db.users.createIndex({ department: 1 })       // For lookup

// Orders collection  
db.orders.createIndex({ userId: 1 })           // For lookup

db.orders.aggregate([
  { $match: { status: &quot;pending&quot; } },           // Use index on orders
  { $lookup: {
      from: &quot;users&quot;,
      localField: &quot;userId&quot;,                     // Uses userId index
      foreignField: &quot;_id&quot;,                      // Uses _id index
      as: &quot;user&quot;
  }}
])</code></pre>
        <div class="notes">
        <p><strong>Major Gotcha:</strong> â€œ$lookup is powerful but
        dangerous at scale. I call it the â€˜performance cliffâ€™ - works
        great until it doesnâ€™t.â€</p>
        <p><strong>Scale Reality:</strong> â€œWhat works with 1000
        documents fails spectacularly with 1 million.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="lookup-performance-pitfalls">âš ï¸ $lookup Performance
        Pitfalls</h1>
        <h2 id="the-hidden-scalability-problem">The Hidden Scalability
        Problem</h2>
        <pre><code>// LOOKS GOOD in development (1K docs)
db.orders.aggregate([
  { $lookup: {
      from: &quot;products&quot;,
      localField: &quot;productId&quot;,
      foreignField: &quot;sku&quot;,              // NOT _id!
      as: &quot;product&quot;
  }}
])

// DISASTER in production (500K+ docs)
// Each lookup becomes individual query!
// 10,000 orders = 10,000 separate index lookups</code></pre>
        <p><strong>Reality Check:</strong> $lookup doesnâ€™t work like SQL
        JOINs</p>
        <div class="notes">
        <p><strong>Dramatic Pause:</strong> â€œThis slide has saved
        companies from multi-hour queries and potential downtime.â€</p>
        <p><strong>Technical Reality:</strong> â€œMongoDB isnâ€™t SQL.
        $lookup doesnâ€™t work like JOINs. Plan accordingly.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="lookup-when-it-goes-wrong">ğŸš¨ $lookup: When It Goes
        Wrong</h1>
        <h2 id="problem-scenarios">Problem Scenarios</h2>
        <pre><code>// BAD: Non-_id field lookups at scale
{ $lookup: { foreignField: &quot;email&quot; } }        // Slow with large collections
{ $lookup: { foreignField: &quot;customerId&quot; } }   // Not optimized like _id

// BAD: Complex filtering in lookup
{ $lookup: {
    from: &quot;users&quot;,
    let: { orderId: &quot;$_id&quot; },
    pipeline: [
      { $match: { 
          $expr: { $eq: [&quot;$orders&quot;, &quot;$$orderId&quot;] },
          status: &quot;active&quot;,                      // Additional filtering
          region: { $in: [&quot;US&quot;, &quot;CA&quot;] }         // Compound conditions
      }}
    ]
}}</code></pre>
        <div class="notes">
        <p><strong>Continuation:</strong> This slide continues the
        content from the previous slide.</p>
        <p><strong>Key Focus:</strong> Maintain the same energy and
        emphasis from the previous section.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="lookup-when-it-goes-wrong-performance">ğŸš¨ $lookup: When
        It Goes Wrong (Performance)</h1>
        <p><strong>Performance Impact:</strong> O(n Ã— m) instead of
        expected O(log n)</p>
        <div class="notes">
        <p><strong>Continuation:</strong> This slide continues the
        content from the previous slide.</p>
        <p><strong>Key Focus:</strong> Maintain the same energy and
        emphasis from the previous section.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="lookup-performance-reality">ğŸ“Š $lookup Performance
        Reality</h1>
        <h2 id="the-numbers-dont-lie">The Numbers Donâ€™t Lie</h2>
        <pre><code>// Small scale (1-10K docs): Works fine
Orders: 5,000 documents
Users: 2,000 documents  
Lookup time: ~50ms âœ…

// Medium scale (50-100K docs): Starts degrading
Orders: 75,000 documents
Users: 50,000 documents
Lookup time: ~2,500ms âš ï¸

// Large scale (500K+ docs): Major performance issues
Orders: 500,000 documents  
Users: 200,000 documents
Lookup time: ~45,000ms âŒ (45 seconds!)</code></pre>
        <div class="notes">
        <p><strong>Teaching Point:</strong> â€œNot all $lookup operations
        are evil. When used correctly with small, filtered datasets,
        theyâ€™re perfectly fine.â€</p>
        <p><strong>Key Strategy:</strong> â€œThe secret is reducing
        dataset size BEFORE the lookup, not after.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="when-lookup-works-well">âœ… When $lookup Works Well</h1>
        <h2 id="efficient-lookup-patterns">Efficient $lookup
        Patterns</h2>
        <pre><code>// GOOD: _id lookups (always fast)
{ $lookup: { foreignField: &quot;_id&quot; } }

// GOOD: Small, filtered datasets first
db.orders.aggregate([
  { $match: { date: { $gte: today } } },      // Reduce dataset FIRST
  { $limit: 100 },                            // Limit early
  { $lookup: { ... } }                        // Then lookup
])</code></pre>
        <p><strong>Key Strategy:</strong> Filter and limit before lookup
        operations</p>
        <div class="notes">
        <p><strong>Design Philosophy:</strong> â€œSometimes the best way
        to optimize a $lookup is to avoid it entirely.â€</p>
        <p><strong>Real-World Advice:</strong> â€œDenormalization isnâ€™t a
        dirty word - itâ€™s a valid design choice for performance-critical
        paths.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="lookup-alternatives-at-scale">ğŸ”„ $lookup Alternatives at
        Scale</h1>
        <h2 id="better-patterns-for-large-collections">Better Patterns
        for Large Collections</h2>
        <pre><code>// Option 1: Embed data (denormalization)
{
  _id: ObjectId(&quot;...&quot;),
  productName: &quot;iPhone 14&quot;,                   // Embed frequently accessed data
  productPrice: 999,
  productSku: &quot;IPHONE14-128&quot;
}

// Option 2: Application-level joins
const orders = await db.orders.find({ status: &quot;pending&quot; });
const userIds = orders.map(o =&gt; o.userId);
const users = await db.users.find({ _id: { $in: userIds } });</code></pre>
        <p><strong>Performance Tip:</strong> Sometimes avoiding $lookup
        entirely is the best solution</p>
        <div class="notes">
        <p><strong>Production Horror Story:</strong> â€œI once saw a
        $lookup bring down a 20-node cluster. The query looked innocent
        in development.â€</p>
        <p><strong>Scale Mathematics:</strong> â€œSmall collections scale
        linearly. Large collections scale exponentially. Know the
        difference.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="update-delete-optimization">âœï¸ Update &amp; Delete
        Optimization</h1>
        <h2 id="update-operations">Update Operations</h2>
        <pre><code>// Single document update - uses index
db.users.updateOne(
  { email: &quot;john@example.com&quot; },      // Filter uses index
  { $set: { lastLogin: new Date() } }
)

// Multi-document update - benefits from index
db.users.updateMany(
  { status: &quot;inactive&quot; },             // Filter uses index
  { $set: { archived: true } }
)

// Index needed: { email: 1 } and { status: 1 }</code></pre>
        <div class="notes">
        <p><strong>Often Overlooked:</strong> â€œDevelopers obsess over
        read performance but forget that writes need indexes too.â€</p>
        <p><strong>Practical Impact:</strong> â€œSlow updates can lock
        your database and create cascading failures.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="delete-optimization">ğŸ—‘ï¸ Delete Optimization</h1>
        <pre><code>// Efficient delete with index
db.users.deleteMany({ 
  status: &quot;inactive&quot;, 
  lastLogin: { $lt: new Date(&quot;2023-01-01&quot;) } 
})

// Optimal index: { status: 1, lastLogin: 1 }</code></pre>
        <p><strong>Key Point:</strong> Delete operations scan first,
        then delete. Good indexes make the scan fast!</p>
        <div class="notes">
        <p><strong>Scaling Reality:</strong> â€œDeletes can be trickier
        than selects. The documents have to be found before they can be
        removed.â€</p>
        <p><strong>Optimization Strategy:</strong> â€œIf youâ€™re deleting
        lots of data regularly, consider TTL indexes or archival
        strategies.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="mongoose-specific-indexing">ğŸ”§ Mongoose-Specific
        Indexing</h1>
        <h2 id="schema-level-index-definition">Schema-Level Index
        Definition</h2>
        <pre><code>const userSchema = new mongoose.Schema({
  email: { 
    type: String, 
    required: true,
    index: true,        // Single field index
    unique: true        // Unique constraint
  },
  status: String,
  age: Number,
  lastLogin: Date
});

// Compound indexes
userSchema.index({ status: 1, age: 1 });
userSchema.index({ status: 1, lastLogin: -1 });</code></pre>
        <div class="notes">
        <p><strong>Practical Tips:</strong> â€œThese patterns separate
        junior developers from senior ones. Small changes, huge
        impact.â€</p>
        <p><strong>Real Impact:</strong> â€œ.lean() alone can make your
        API 3x faster by skipping Mongoose overhead.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="mongoose-specific-indexing-part-2">ğŸ”§ Mongoose-Specific
        Indexing (Part 2)</h1>
        <div class="notes">
        <p><strong>Developer Experience:</strong> â€œMongoose makes
        indexes feel like first-class citizens in your code. Your schema
        becomes your performance documentation.â€</p>
        <p><strong>Best Practice:</strong> â€œDefine indexes at the schema
        level so every developer gets consistent performance. Itâ€™s like
        having performance guardrails built into your codebase.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="mongoose-query-optimization">ğŸš€ Mongoose Query
        Optimization</h1>
        <pre><code>// GOOD: Use lean() for read-only queries
const users = await User.find({ status: &quot;active&quot; })
  .lean()                    // Skip Mongoose document wrapper
  .select(&#39;name email&#39;)      // Project only needed fields
  .limit(100);

// GOOD: Use explain() to check query plans
const explained = await User.find({ status: &quot;active&quot; }).explain();
console.log(explained.executionStats);

// GOOD: Use proper field types
const User = new Schema({
  _id: { type: mongoose.Schema.Types.ObjectId }, // Proper ObjectId
  email: { type: String, lowercase: true }        // Consistent format
});</code></pre>
        <div class="notes">
        <p><strong>Developer Experience:</strong> â€œMongoose makes
        indexing declarative. Your schema becomes your performance
        documentation.â€</p>
        <p><strong>Team Coordination:</strong> â€œSchema-level indexes
        ensure every developer on your team gets the same performance
        characteristics.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="common-pitfalls-anti-patterns">âš ï¸ Common Pitfalls &amp;
        Anti-Patterns</h1>
        <h2 id="wrong-index-field-order">1. Wrong Index Field Order</h2>
        <pre><code>// BAD: Wrong order for this query
db.users.createIndex({ age: 1, status: 1 })
db.users.find({ status: &quot;active&quot;, age: { $gte: 25 } }).sort({ name: 1 })

// GOOD: Follow ESR principle
db.users.createIndex({ status: 1, name: 1, age: 1 })</code></pre>
        <div class="notes">
        <p><strong>War Stories:</strong> â€œEvery one of these
        anti-patterns represents a production incident Iâ€™ve seen. Learn
        from othersâ€™ pain.â€</p>
        <p><strong>Pattern Recognition:</strong> â€œGood developers
        recognize these patterns during code review, not in production
        monitoring.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="common-pitfalls-anti-patterns-2.-too-many-indexes">âš ï¸
        Common Pitfalls &amp; Anti-Patterns (2. Too Many Indexes)</h1>
        <h2 id="too-many-indexes">2. Too Many Indexes</h2>
        <pre><code>// BAD: Index overload
db.users.createIndex({ email: 1 })
db.users.createIndex({ status: 1 })
db.users.createIndex({ age: 1 })
db.users.createIndex({ city: 1 })
// Every write now updates 5 indexes!</code></pre>
        <div class="notes">
        <p><strong>Balance Act:</strong> â€œIndexes are like seasoning.
        Too little and your queries are bland. Too much and you
        overwhelm the system.â€</p>
        <p><strong>Maintenance Reality:</strong> â€œEvery index you add
        makes writes slower. Choose wisely.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="common-pitfalls-anti-patterns-part-3">âš ï¸ Common Pitfalls
        &amp; Anti-Patterns (Part 3)</h1>
        <div class="notes">
        <p><strong>Continuation:</strong> This slide continues the
        content from the previous slide.</p>
        <p><strong>Key Focus:</strong> Maintain the same energy and
        emphasis from the previous section.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="regex-anti-patterns">ğŸš« Regex Anti-Patterns</h1>
        <h2 id="regex-optimization-misunderstandings">Regex Optimization
        Misunderstandings</h2>
        <pre><code>// BAD: Unanchored with regex operators
db.users.find({ email: { $regex: /gm.*il/ } })      // Collection scan!

// OK: Static text (MongoDB can sometimes optimize)
db.users.find({ email: { $regex: /gmail/ } })       // May use index bounds

// GOOD: Left-anchored regex can use index
db.users.find({ email: { $regex: /^john/ } })</code></pre>
        <p><strong>Key Point:</strong> Regex operators (<code>.</code>,
        <code>*</code>, <code>+</code>) prevent index usage when
        unanchored</p>
        <p><strong>See regex optimization deep dive for complete
        details</strong></p>
        <div class="notes">
        <p><strong>Critical Point:</strong> â€œThis is one of MongoDBâ€™s
        most misunderstood features. Developers assume all regex queries
        are the same, but thereâ€™s a huge performance difference.â€</p>
        <p><strong>Teaching Moment:</strong> â€œStatic text like /gmail/
        is different from operators like /gm.*il/ - MongoDB can
        sometimes optimize static patterns.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="negative-query-anti-patterns">ğŸš« Negative Query
        Anti-Patterns</h1>
        <h2 id="ne-and-nin-performance-problems">$ne and $nin
        Performance Problems</h2>
        <pre><code>// BAD: These scan entire collection
db.users.find({ status: { $ne: &quot;deleted&quot; } })
db.users.find({ status: { $nin: [&quot;deleted&quot;, &quot;banned&quot;] } })

// GOOD: Use positive conditions instead
db.users.find({ status: { $in: [&quot;active&quot;, &quot;pending&quot;] } })</code></pre>
        <p><strong>Why This Matters:</strong> Negative queries examine
        most documents in your collection</p>
        <div class="notes">
        <p><strong>Key Point:</strong> [Add speaker notes for this
        slide]</p>
        <p><strong>Emphasis:</strong> [Add key talking points]</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="lookup-scale-anti-patterns">ğŸš« $lookup Scale
        Anti-Patterns</h1>
        <h2 id="naive-lookup-assumptions">Naive $lookup Assumptions</h2>
        <pre><code>// BAD: Assumes $lookup scales like SQL JOINs
db.orders.aggregate([
  { $lookup: { foreignField: &quot;customerId&quot; } }  // Disaster with 500K+ docs!
])

// GOOD: Filter first, lookup small datasets
db.orders.aggregate([
  { $match: { date: { $gte: today } } },      // Reduce dataset FIRST
  { $lookup: { foreignField: &quot;customerId&quot; } }
])</code></pre>
        <p><strong>Reality Check:</strong> $lookup doesnâ€™t work like SQL
        JOINs at scale</p>
        <div class="notes">
        <p><strong>Scale Reality Check:</strong> â€œThis is where
        developers get burned. $lookup works beautifully in development
        with 1000 docs, then becomes a disaster in production with 1
        million.â€</p>
        <p><strong>Prevention Strategy:</strong> â€œAlways ask: â€˜What
        happens when this collection has 500K documents?â€™ If the answer
        scares you, redesign before deployment.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="critical-index-anti-patterns">ğŸš¨ Critical Index
        Anti-Patterns</h1>
        <h2 id="multiple-range-queries-index-disaster">Multiple Range
        Queries = Index Disaster</h2>
        <pre><code>// BAD: Multiple ranges can&#39;t use compound index efficiently
db.products.find({ 
  price: { $gte: 100, $lte: 500 },      // Range 1
  weight: { $gte: 1, $lte: 10 },        // Range 2  
  rating: { $gte: 4.0 }                 // Range 3
})

// Index: { price: 1, weight: 1, rating: 1 }
// Reality: Only price range can use index efficiently!
// weight and rating become collection scans</code></pre>
        <p><strong>Rule:</strong> Only ONE range condition per query can
        use index efficiently</p>
        <div class="notes">
        <p><strong>System Impact:</strong> â€œThese arenâ€™t just slow
        queries - theyâ€™re cluster killers.â€</p>
        <p><strong>Recognition Training:</strong> â€œPractice spotting
        these patterns during development, not monitoring alerts.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="in-array-size-anti-patterns">ğŸ’¥ $in Array Size
        Anti-Patterns</h1>
        <h2 id="when-in-becomes-your-enemy">When $in Becomes Your
        Enemy</h2>
        <pre><code>// BAD: Large $in arrays kill performance
const userIds = [...Array(10000)].map(() =&gt; new ObjectId()); // 10K IDs!
db.orders.find({ userId: { $in: userIds } })

// Performance characteristics:
// 100 IDs in $in: ~50ms âœ…
// 1,000 IDs in $in: ~500ms âš ï¸  
// 10,000 IDs in $in: ~15,000ms âŒ (15 seconds!)</code></pre>
        <div class="notes">
        <p><strong>Practical Limits:</strong> â€œIâ€™ve seen developers put
        10,000 IDs in a $in query. It doesnâ€™t end well.â€</p>
        <p><strong>Alternative Strategies:</strong> â€œSometimes a lookup
        table or denormalization is better than a massive $in.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="in-array-size-anti-patterns-better-approaches">ğŸ’¥ $in
        Array Size Anti-Patterns (Better Approaches)</h1>
        <p><strong>Better Approaches:</strong> // Option 1: Batch
        processing for (const batch of chunks(userIds, 500)) { await
        db.orders.find({ userId: { $in: batch } }); }</p>
        <pre><code>// Option 2: Flip the query
db.orders.find({ userId: { $exists: true } })
  .forEach(order =&gt; {
    if (userIdSet.has(order.userId)) { /* process */ }
  });</code></pre>
        <div class="notes">
        <p><strong>Performance Disaster:</strong> â€œIâ€™ve seen developers
        put 10,000 IDs in a $in query and wonder why their app crashes.
        Size matters!â€</p>
        <p><strong>Real Numbers:</strong> â€œWatch the performance cliff:
        100 IDs = fine, 1,000 IDs = concerning, 10,000 IDs = system
        killer.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="in-array-size-anti-patterns-part-3">ğŸ’¥ $in Array Size
        Anti-Patterns (Part 3)</h1>
        <div class="notes">
        <p><strong>Continuation:</strong> This slide continues the
        content from the previous slide.</p>
        <p><strong>Key Focus:</strong> Maintain the same energy and
        emphasis from the previous section.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="array-index-scalability-pitfalls">ğŸ—‚ï¸ Array Index
        Scalability Pitfalls</h1>
        <h2 id="multikey-index-performance-degradation">Multikey Index
        Performance Degradation</h2>
        <pre><code>// Document with large arrays
{
  _id: ObjectId(&quot;...&quot;),
  tags: [&quot;electronics&quot;, &quot;mobile&quot;, &quot;smartphone&quot;, /* ...500 more tags */],
  categories: [&quot;tech&quot;, &quot;gadgets&quot;, /* ...200 more categories */]
}

// Index on array fields
db.products.createIndex({ tags: 1, categories: 1 })

// Problems:
// 1. Index size explodes: 500 Ã— 200 = 100,000 index entries per document!
// 2. Write performance degrades severely
// 3. Memory usage skyrockets</code></pre>
        <div class="notes">
        <p><strong>Hidden Complexity:</strong> â€œArrays seem simple but
        create complex indexing challenges.â€</p>
        <p><strong>Performance Cliff:</strong> â€œArrays with hundreds of
        elements can make indexes unusable.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="array-index-scalability-pitfalls-solutions">ğŸ—‚ï¸ Array
        Index Scalability Pitfalls (Solutions)</h1>
        <p><strong>Solutions:</strong> // Option 1: Limit array sizes {
        maxArraySize: 50 } // Enforce in application</p>
        <pre><code>// Option 2: Use text index for searchable arrays
db.products.createIndex({ tags: &quot;text&quot; })

// Option 3: Separate collection for array items
// products collection + product_tags collection</code></pre>
        <div class="notes">
        <p><strong>Hidden Complexity:</strong> â€œArrays look innocent but
        theyâ€™re index killers. One document with 500 tags creates 500
        index entries!â€</p>
        <p><strong>Memory Explosion:</strong> â€œIâ€™ve seen apps crash
        because a single document had 10,000 array elements. Thatâ€™s
        10,000 index entries per document.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="group-sort-anti-patterns">ğŸ“Š Group &amp; Sort
        Anti-Patterns</h1>
        <h2 id="the-wrong-order-trap">The Wrong Order Trap</h2>
        <pre><code>// BAD: Sort after group = in-memory sort
db.orders.aggregate([
  { $group: { 
      _id: &quot;$customerId&quot;, 
      totalAmount: { $sum: &quot;$amount&quot; },
      orderCount: { $sum: 1 }
  }},
  { $sort: { totalAmount: -1 } }        // Can&#39;t use index!
])

// GOOD: Sort before group when possible
db.orders.aggregate([
  { $sort: { customerId: 1, amount: -1 } },  // Uses index
  { $group: { 
      _id: &quot;$customerId&quot;,
      maxAmount: { $first: &quot;$amount&quot; },       // Pre-sorted!
      totalAmount: { $sum: &quot;$amount&quot; }
  }}
])

// Index: { customerId: 1, amount: -1 }</code></pre>
        <div class="notes">
        <p><strong>Pipeline Wisdom:</strong> â€œOrder matters in
        aggregation pipelines. Sort before group when possible.â€</p>
        <p><strong>Memory Reality:</strong> â€œIn-memory sorts are
        performance killers at scale.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="group-sort-anti-patterns-part-2">ğŸ“Š Group &amp; Sort
        Anti-Patterns (Part 2)</h1>
        <div class="notes">
        <p><strong>Continuation:</strong> This slide continues the
        content from the previous slide.</p>
        <p><strong>Key Focus:</strong> Maintain the same energy and
        emphasis from the previous section.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="compound-index-vs-multiple-ranges">ğŸ¯ Compound Index vs
        Multiple Ranges</h1>
        <h2 id="the-selectivity-problem">The Selectivity Problem</h2>
        <pre><code>// BAD: Low selectivity fields with ranges
db.events.find({
  type: &quot;click&quot;,                         // Low selectivity (90% of docs)
  timestamp: { $gte: yesterday },        // Range
  userId: { $in: [1000 user IDs] }      // High selectivity
})

// Index: { type: 1, timestamp: 1, userId: 1 }
// Problem: Scans 90% of collection before filtering!

// GOOD: High selectivity first
// Index: { userId: 1, type: 1, timestamp: 1 }
// Finds specific users first, then filters</code></pre>
        <p><strong>Selectivity Rule:</strong> Most selective fields
        first, especially before ranges</p>
        <div class="notes">
        <p><strong>Critical Limitation:</strong> â€œThis is MongoDBâ€™s
        achilles heel - only one range per index scan. Multiple ranges =
        performance problems.â€</p>
        <p><strong>Design Implication:</strong> â€œWhen you see queries
        with multiple $gte, $lte, or $in operations, thatâ€™s your cue to
        redesign the query or data model.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="regex-optimization-deep-dive">ğŸ” Regex Optimization Deep
        Dive</h1>
        <h2 id="static-text-vs-regex-operators">Static Text vs Regex
        Operators</h2>
        <pre><code>// SURPRISING: These can sometimes use indexes even unanchored!
db.users.find({ name: { $regex: /john/ } })        // Static text
db.users.find({ name: { $regex: /smith/ } })       // Static text
db.users.find({ name: { $regex: /admin/ } })       // Static text

// NEVER optimized: Regex operators can&#39;t use index unanchored
db.users.find({ name: { $regex: /joh+n/ } })       // + operator
db.users.find({ name: { $regex: /sm.*th/ } })      // . and * operators  
db.users.find({ name: { $regex: /admin?/ } })      // ? operator</code></pre>
        <p><strong>Key Insight:</strong> MongoDB can sometimes optimize
        static text searches</p>
        <div class="notes">
        <p><strong>Subtle Distinction:</strong> â€œThis is one of
        MongoDBâ€™s best-kept secrets. Not all regex patterns are created
        equal.â€</p>
        <p><strong>Performance Surprise:</strong> â€œA simple text search
        can sometimes use indexes even when you donâ€™t expect it.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="mongodbs-smart-regex-optimizations">âš¡ MongoDBâ€™s Smart
        Regex Optimizations</h1>
        <h2 id="the-hidden-index-magic">The Hidden Index Magic</h2>
        <pre><code>// Index: { name: 1 }

// MongoDB CAN optimize these (static text):
/john/           // Looks for &quot;john&quot; substring - can use index bounds!
/smith/          // Looks for &quot;smith&quot; substring
/company/        // Static text pattern

// MongoDB CANNOT optimize these (regex operators):
/joh+n/          // + means &quot;one or more h&quot; - infinite possibilities
/sm.*th/         // .* means &quot;anything between&quot; - too broad
/compan(y|ies)/  // Alternation - multiple patterns</code></pre>
        <p><strong>Performance Impact:</strong> - Static text: Can
        narrow index scan range - Regex operators: Always full
        collection scan (unless anchored)</p>
        <div class="notes">
        <p><strong>Hidden Intelligence:</strong> â€œMongoDB is smarter
        than you think with regex. Static text patterns can sometimes
        use indexes even when unanchored.â€</p>
        <p><strong>Performance Secret:</strong> â€œThe difference between
        /foo/ and /fo+/ isnâ€™t just syntax - itâ€™s the difference between
        index optimization and collection scans.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="regex-performance-comparison">ğŸ“Š Regex Performance
        Comparison</h1>
        <h2 id="real-performance-numbers">Real Performance Numbers</h2>
        <pre><code>// Test collection: 1M user documents with name field indexed

// Static unanchored (optimizable)
db.users.find({ name: { $regex: /smith/ } })
// Index bounds: [&quot;smith&quot;, &quot;smithz&quot;)  
// Performance: ~100ms, examines ~1000 docs âœ…

// Regex operator unanchored (not optimizable)  
db.users.find({ name: { $regex: /smit+h/ } })
// No index bounds possible
// Performance: ~5000ms, examines ALL 1M docs âŒ

// Left-anchored (always optimizable)
db.users.find({ name: { $regex: /^smit+h/ } })
// Index bounds: [&quot;smit&quot;, &quot;smiu&quot;)
// Performance: ~50ms, examines ~100 docs âœ…</code></pre>
        <div class="notes">
        <p><strong>Benchmarking Story:</strong> â€œThese numbers come from
        real production systems. The differences are dramatic.â€</p>
        <p><strong>Design Decision:</strong> â€œChoose your search
        strategy based on these performance characteristics.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="regex-best-practices">ğŸ¯ Regex Best Practices</h1>
        <h2 id="optimization-strategy">Optimization Strategy</h2>
        <pre><code>// BEST: Use text indexes for complex searches
db.users.createIndex({ name: &quot;text&quot;, email: &quot;text&quot; })
db.users.find({ $text: { $search: &quot;john smith&quot; } })

// GOOD: Left-anchor when possible
db.users.find({ email: { $regex: /^john.*@company\.com$/ } })

// OK: Static text (MongoDB optimizes some cases)
db.users.find({ name: { $regex: /john/ } })

// BAD: Unanchored with regex operators
db.users.find({ name: { $regex: /joh+n.*smith/ } })</code></pre>
        <div class="notes">
        <p><strong>War Story:</strong> â€œIâ€™ve seen developers create
        compound indexes for single-field queries. It works, but itâ€™s
        like using a Ferrari to go to the grocery store - wasteful and
        unnecessary.â€</p>
        <p><strong>Memory Trick:</strong> â€œThink of cardinality like
        lanes on a highway. High cardinality = more lanes = less traffic
        jams.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="regex-best-practices-case-sensitivity-gotcha">ğŸ¯ Regex
        Best Practices (Case Sensitivity Gotcha)</h1>
        <h2 id="case-sensitivity-gotcha">Case Sensitivity Gotcha</h2>
        <pre><code>// BAD: Case-insensitive kills optimization
db.users.find({ name: { $regex: /john/i } })        // Collection scan!

// GOOD: Store data in consistent case
db.users.find({ name: { $regex: /john/ } })         // Can optimize
// Ensure data is stored as: &quot;John Smith&quot; or &quot;john smith&quot; consistently</code></pre>
        <div class="notes">
        <p><strong>Implementation Guide:</strong> â€œText indexes vs regex
        optimization - know when to use which.â€</p>
        <p><strong>Performance Planning:</strong> â€œCase sensitivity
        isnâ€™t just about user experience - itâ€™s about performance.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="selectivity-and-performance">ğŸ“Š Selectivity and
        Performance</h1>
        <h2 id="understanding-selectivity">Understanding
        Selectivity</h2>
        <pre><code>// High selectivity (GOOD) - finds few documents
db.users.find({ email: &quot;john@example.com&quot; })      // 1 out of 1M

// Medium selectivity (OK) - finds some documents  
db.users.find({ city: &quot;New York&quot; })               // 50K out of 1M

// Low selectivity (BAD) - finds many documents
db.users.find({ status: &quot;active&quot; })               // 900K out of 1M</code></pre>
        <p><strong>Rule:</strong> More selective fields should come
        first in compound indexes</p>
        <div class="notes">
        <p><strong>Operational Excellence:</strong> â€œYou canâ€™t optimize
        what you canâ€™t measure.â€</p>
        <p><strong>Proactive Approach:</strong> â€œSet up monitoring
        before you have problems, not after.â€</p>
        <p><strong>Diagnostic Power:</strong> â€œexplain() is your X-ray
        vision into MongoDBâ€™s decision-making process. Use it
        religiously.â€</p>
        <p><strong>Key Metrics:</strong> â€œFocus on the ratio:
        docsExamined vs docsReturned. If youâ€™re examining 10,000 to
        return 10, you have a problem.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="index-monitoring-analysis">ğŸ› ï¸ Index Monitoring &amp;
        Analysis</h1>
        <h2 id="using-explain">Using explain()</h2>
        <pre><code>// Get execution statistics
const result = await db.users.find({ status: &quot;active&quot; }).explain(&quot;executionStats&quot;);

console.log({
  indexUsed: result.executionStats.executionStages.indexName,
  docsExamined: result.executionStats.totalDocsExamined,
  docsReturned: result.executionStats.totalDocsReturned,
  executionTime: result.executionStats.executionTimeMillis
});</code></pre>
        <p><strong>Key Metrics:</strong> -
        <code>totalDocsExamined</code> vs <code>totalDocsReturned</code>
        (lower ratio = better) - <code>executionTimeMillis</code> (lower
        = better) - <code>indexName</code> (should not be null)</p>
        <div class="notes">
        <p><strong>Warning Signs:</strong> â€œCOLLSCAN is the four-letter
        word of MongoDB. When you see it, everything else stops until
        itâ€™s fixed.â€</p>
        <p><strong>Emergency Response:</strong> â€œCollection scans in
        production are like fire alarms - immediate attention
        required.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="collection-scan-detection">ğŸ“ˆ Collection Scan
        Detection</h1>
        <pre><code>// Signs of collection scans:
{
  &quot;stage&quot;: &quot;COLLSCAN&quot;,                    // No index used
  &quot;totalDocsExamined&quot;: 1000000,           // Examined all docs
  &quot;totalDocsReturned&quot;: 1,                 // Returned few docs
  &quot;executionTimeMillis&quot;: 1250             // High execution time
}

// Good index usage:
{
  &quot;stage&quot;: &quot;IXSCAN&quot;,                      // Index scan
  &quot;indexName&quot;: &quot;status_1_age_1&quot;,          // Used specific index
  &quot;totalDocsExamined&quot;: 5,                 // Examined few docs
  &quot;totalDocsReturned&quot;: 5,                 // Returned matched docs
  &quot;executionTimeMillis&quot;: 2                // Fast execution
}</code></pre>
        <div class="notes">
        <p><strong>Continuation:</strong> This slide continues the
        content from the previous slide.</p>
        <p><strong>Key Focus:</strong> Maintain the same energy and
        emphasis from the previous section.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="collection-scan-detection-part-2">ğŸ“ˆ Collection Scan
        Detection (Part 2)</h1>
        <div class="notes">
        <p><strong>Actionable Wisdom:</strong> â€œThese arenâ€™t theoretical
        principles - theyâ€™re battle-tested rules that have saved
        countless production systems.â€</p>
        <p><strong>Implementation Strategy:</strong> â€œDonâ€™t try to
        implement everything at once. Pick the three most impactful
        practices for your current codebase and start there.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="best-practices-summary">ğŸ¯ Best Practices Summary</h1>
        <h2 id="index-design">Index Design</h2>
        <ol type="1">
        <li><strong>Follow ESR rule</strong> for compound indexes</li>
        <li><strong>Put selective fields first</strong> in compound
        indexes</li>
        <li><strong>Create indexes for your query patterns</strong>, not
        your data structure</li>
        <li><strong>Use covering indexes</strong> when possible</li>
        <li><strong>Limit array sizes</strong> to prevent multikey index
        explosion</li>
        </ol>
        <h2 id="query-writing">Query Writing</h2>
        <ol type="1">
        <li><strong>Avoid $ne, $nin, and unanchored regex with
        operators</strong></li>
        <li><strong>Use projection</strong> to limit returned
        fields</li>
        <li><strong>Limit result sets</strong> with
        <code>.limit()</code></li>
        <li><strong>Use explain()</strong> to verify index usage</li>
        <li><strong>Batch large $in arrays</strong> (max ~500-1000
        items)</li>
        <li><strong>Only one range condition</strong> per query</li>
        <li><strong>Sort before group</strong> when possible</li>
        <li><strong>Prefer static text regex</strong> over
        operator-based patterns</li>
        </ol>
        <div class="notes">
        <p><strong>Development Integration:</strong> â€œIndexing isnâ€™t a
        post-deployment afterthought. Build it into your development
        workflow from day one.â€</p>
        <p><strong>Production Readiness:</strong> â€œSet up profiling in
        development so you catch performance issues before your users
        do.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="development-workflow">ğŸ”§ Development Workflow</h1>
        <h2 id="development-phase">1. Development Phase</h2>
        <pre><code>// Enable profiling for slow queries
db.setProfilingLevel(2, { slowms: 100 })

// Use explain in development
const query = User.find({ status: &quot;active&quot; });
console.log(await query.explain());</code></pre>
        <h2 id="production-monitoring">2. Production Monitoring</h2>
        <pre><code>// Monitor slow operations
db.runCommand({ profile: 0 })
db.system.profile.find().sort({ ts: -1 }).limit(5)

// Check index usage statistics
db.users.aggregate([{ $indexStats: {} }])</code></pre>
        <div class="notes">
        <p><strong>Tool Mastery:</strong> â€œMongoDB Compass isnâ€™t just
        pretty - itâ€™s powerful. Learn to use these tools before you need
        them in a crisis.â€</p>
        <p><strong>Continuous Learning:</strong> â€œThe MongoDB ecosystem
        evolves rapidly. Bookmark these resources and check back
        regularly for new optimization opportunities.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="tools-resources">ğŸ“š Tools &amp; Resources</h1>
        <h2 id="mongodb-tools">MongoDB Tools</h2>
        <ul>
        <li><strong>MongoDB Compass</strong> - Visual index
        analysis</li>
        <li><strong>db.collection.explain()</strong> - Query plan
        analysis</li>
        <li><strong>Database Profiler</strong> - Slow query
        detection</li>
        <li><strong>$indexStats</strong> - Index usage statistics</li>
        </ul>
        <h2 id="mongoose-tools">Mongoose Tools</h2>
        <ul>
        <li><strong>query.explain()</strong> - Mongoose wrapper for
        explain</li>
        <li><strong>Schema.index()</strong> - Schema-level index
        definition</li>
        <li><strong>mongoose.set(â€˜debugâ€™, true)</strong> - Query
        logging</li>
        </ul>
        <div class="notes">
        <p><strong>Practical Application:</strong> â€œThis e-commerce
        example shows ESR in action. Notice how category and inStock
        come before price range - thatâ€™s ESR working.â€</p>
        <p><strong>Real Performance Impact:</strong> â€œThis single index
        design could be the difference between 50ms response times and
        5-second timeouts in production.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="real-world-example">ğŸš€ Real-World Example</h1>
        <pre><code>// E-commerce product search
const productSchema = new Schema({
  name: String,
  category: String,
  price: Number,
  inStock: Boolean,
  rating: Number,
  tags: [String]
});

// Query: Find in-stock products in category, sorted by rating
Product.find({ 
  category: &quot;electronics&quot;,     // Equality
  inStock: true,              // Equality  
  price: { $lte: 1000 }       // Range
}).sort({ rating: -1 })       // Sort

// Optimal index: ESR pattern
productSchema.index({ category: 1, inStock: 1, rating: -1, price: 1 });</code></pre>
        <div class="notes">
        <p><strong>Continuation:</strong> This slide continues the
        content from the previous slide.</p>
        <p><strong>Key Focus:</strong> Maintain the same energy and
        emphasis from the previous section.</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="real-world-example-part-2">ğŸš€ Real-World Example (Part
        2)</h1>
        <div class="notes">
        <p><strong>Immediate Action:</strong> â€œDonâ€™t let this knowledge
        sit idle. Schedule index audits and profiling setup this
        week.â€</p>
        <p><strong>Prioritization:</strong> â€œStart with your slowest
        queries and most critical features. Big impact, manageable
        scope.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="action-items">ğŸ“‹ Action Items</h1>
        <h2 id="immediate-steps">Immediate Steps</h2>
        <ol type="1">
        <li><strong>Audit existing queries</strong> - Run explain() on
        slow queries</li>
        <li><strong>Review current indexes</strong> - Remove unused, add
        missing</li>
        <li><strong>Enable query profiling</strong> - Identify
        problematic queries</li>
        <li><strong>Add schema-level indexes</strong> - Define in
        Mongoose schemas</li>
        </ol>
        <h2 id="ongoing-practices">Ongoing Practices</h2>
        <ol type="1">
        <li><strong>Test query performance</strong> - Use explain() in
        development</li>
        <li><strong>Monitor production metrics</strong> - Track slow
        queries and index usage</li>
        <li><strong>Regular index maintenance</strong> - Review and
        optimize quarterly</li>
        </ol>
        <div class="notes">
        <p><strong>Memory Anchors:</strong> â€œESR, selectivity, and
        anti-pattern avoidance - these three concepts will solve 90% of
        your indexing problems.â€</p>
        <p><strong>Mindset Shift:</strong> â€œThink like the optimizer.
        Design indexes for how MongoDB searches, not how humans organize
        data.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="key-takeaways">ğŸ‰ Key Takeaways</h1>
        <h2 id="remember-these-rules">Remember These Rules</h2>
        <ol type="1">
        <li><strong>Indexes are about query patterns, not data
        structure</strong></li>
        <li><strong>ESR (Equality, Sort, Range) for compound
        indexes</strong></li>
        <li><strong>Left-to-right rule for compound index
        usage</strong></li>
        <li><strong>High selectivity fields come first</strong></li>
        <li><strong>Every index has a write cost</strong></li>
        <li><strong>Only ONE range query can use index
        efficiently</strong></li>
        <li><strong>Large $in arrays (&gt;1000) kill
        performance</strong></li>
        <li><strong>Array indexes explode with large/multiple
        arrays</strong></li>
        <li><strong>Static text regex (/foo/) can optimize, operators
        (/foo+/) cannot</strong></li>
        </ol>
        <div class="notes">
        <p><strong>Performance Culture:</strong> â€œMake explain() as
        routine as console.log(). Performance optimization should be
        part of your daily development.â€</p>
        <p><strong>Continuous Improvement:</strong> â€œIndexing isnâ€™t a
        one-time fix - itâ€™s an ongoing optimization practice as your
        application evolves.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="key-takeaways-critical-anti-patterns-to-avoid">ğŸ‰ Key
        Takeaways (Critical Anti-Patterns to Avoid)</h1>
        <h2 id="critical-anti-patterns-to-avoid">Critical Anti-Patterns
        to Avoid</h2>
        <ul>
        <li>Multiple range conditions in one query</li>
        <li>$lookup on non-_id fields at scale</li>
        <li>Sort after group operations</li>
        <li>Large multikey indexes</li>
        <li>Unanchored regex with operators (+, *, ?, etc.)</li>
        </ul>
        <h2 id="test-monitor-optimize">Test, Monitor, Optimize</h2>
        <ul>
        <li>Use <code>explain()</code> religiously</li>
        <li>Monitor slow query logs</li>
        <li>Regular performance reviews</li>
        </ul>
        <div class="notes">
        <p><strong>Engagement Focus:</strong> â€œShare your specific
        challenges - indexing problems are often more nuanced than they
        first appear.â€</p>
        <p><strong>Community Learning:</strong> â€œThe best solutions
        often come from collective experience. Donâ€™t hesitate to
        describe your use case.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="questions-discussion">â“ Questions &amp; Discussion</h1>
        <h2 id="lets-talk-about">Letâ€™s talk about:</h2>
        <ul>
        <li>Your specific query patterns</li>
        <li>Performance challenges youâ€™re facing</li>
        <li>Index strategies for your use cases</li>
        <li>Mongoose optimization techniques</li>
        </ul>
        <p><strong>Thank you for attending!</strong> <em>Happy indexing!
        ğŸš€</em></p>
        <div class="notes">
        <p><strong>Continuous Learning:</strong> â€œMongoDBâ€™s capabilities
        evolve rapidly. These resources will help you stay current with
        new optimization opportunities.â€</p>
        <p><strong>Action Planning:</strong> â€œDonâ€™t just bookmark these
        - set calendar reminders to actually use and explore them.â€</p>
        </div>
        <p>â€”SLIDEâ€”</p>
        <h1 id="additional-resources">ğŸ“– Additional Resources</h1>
        <h2 id="documentation">Documentation</h2>
        <ul>
        <li><a href="https://docs.mongodb.com/manual/indexes/">MongoDB
        Index Documentation</a></li>
        <li><a
        href="https://mongoosejs.com/docs/guide.html#indexes">Mongoose
        Index Documentation</a></li>
        <li><a
        href="https://docs.mongodb.com/manual/core/query-optimization/">Query
        Optimization Guide</a></li>
        </ul>
        <h2 id="tools">Tools</h2>
        <ul>
        <li><a href="https://www.mongodb.com/products/compass">MongoDB
        Compass</a></li>
        <li><a href="https://studio3t.com/">Studio 3T</a> - Query
        profiling</li>
        <li><a
        href="https://github.com/your-repo/IndexAnalyzer">IndexAnalyzer</a>
        - Automated index analysis</li>
        <li><a
        href="https://github.com/your-repo/IndexAnalyzer/tree/main/slides">MongoDB
        Indexing Field Guide</a> - This presentation</li>
        </ul>
        <p><em>Contact: [your-email@company.com]</em></p>
    </div>
    
    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        
        function showSlide(n) {
            const slides = document.querySelectorAll('.slide');
            slides.forEach((slide, index) => {
                slide.style.display = index === n ? 'block' : 'none';
            });
            document.getElementById('slide-counter').textContent = n + 1;
            currentSlide = n;
        }
        
        function nextSlide() {
            const slides = document.querySelectorAll('.slide');
            if (currentSlide < slides.length - 1) {
                showSlide(currentSlide + 1);
            }
        }
        
        function previousSlide() {
            if (currentSlide > 0) {
                showSlide(currentSlide - 1);
            }
        }
        
        function toggleNotes(button) {
            const notesContent = button.nextElementSibling;
            const isVisible = notesContent.classList.contains('show');
            
            if (isVisible) {
                notesContent.classList.remove('show');
                button.textContent = 'ğŸ“ Show Notes';
            } else {
                notesContent.classList.add('show');
                button.textContent = 'ğŸ“ Hide Notes';
            }
        }
        
        // Split content into slides and process notes
        function initializeSlides() {
            const container = document.getElementById('slides-container');
            const content = container.innerHTML;
            
            // Split by our custom slide separator (Pandoc converts ---SLIDE--- to <p>â€”SLIDEâ€”</p>)
            const slideParts = content.split(/<p>â€”SLIDEâ€”<\/p>/);
            const slides = [];
            
            slideParts.forEach((slideContent, index) => {
                if (slideContent.trim()) {
                    const slideDiv = document.createElement('div');
                    slideDiv.className = 'slide';
                    slideDiv.style.display = index === 0 ? 'block' : 'none';
                    
                    const slideContentDiv = document.createElement('div');
                    slideContentDiv.className = 'slide-content';
                    slideContentDiv.innerHTML = slideContent;
                    
                    slideDiv.appendChild(slideContentDiv);
                    slides.push(slideDiv);
                }
            });
            
            // Clear container and add slides
            container.innerHTML = '';
            slides.forEach(slide => container.appendChild(slide));
            
            // Process notes sections
            processNotesSections();
            
            // Initialize navigation with actual slide count
            window.totalSlides = slides.length;
            showSlide(0);
        }
        
        // Process notes sections after page load
        function processNotesSections() {
            const slides = document.querySelectorAll('.slide');
            slides.forEach((slide, slideIndex) => {
                // Find notes blocks (divs with class 'notes')
                const notesBlocks = slide.querySelectorAll('.notes');
                notesBlocks.forEach((notesBlock, notesIndex) => {
                    // Create expandable notes section
                    const notesSection = document.createElement('div');
                    notesSection.className = 'notes-section';
                    
                    const toggleButton = document.createElement('button');
                    toggleButton.className = 'notes-toggle';
                    toggleButton.textContent = 'ğŸ“ Show Notes';
                    toggleButton.onclick = function() { toggleNotes(this); };
                    
                    const notesContent = document.createElement('div');
                    notesContent.className = 'notes-content';
                    
                    const notesTitle = document.createElement('h4');
                    notesTitle.textContent = 'Speaker Notes';
                    
                    notesContent.appendChild(notesTitle);
                    notesContent.appendChild(notesBlock.cloneNode(true));
                    
                    notesSection.appendChild(toggleButton);
                    notesSection.appendChild(notesContent);
                    
                    // Replace the original notes block
                    notesBlock.parentNode.replaceChild(notesSection, notesBlock);
                });
            });
        }
        
        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                previousSlide();
            }
        });
        
        // Initialize slides after DOM is loaded
        document.addEventListener('DOMContentLoaded', initializeSlides);
        // Also process immediately in case DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeSlides);
        } else {
            initializeSlides();
        }
    </script>
</body>
</html>
